Day1:
Angular
app.module - bootstratp: [AppComponent] root of all components for this application
		So all components roll up here
	     imports: [other, modules] as globally usable throughout the application
component  - Provides data for the view templates
package.json - Manages dependencies + versions.  One level higher than src
angular.json - The app configuration
node_modules - 100's of listed dependencies listed out
webpack -Compiles code to JS + injects JS into index.html (5 files)
npm install bootstrap font-awesome
src>styles.css @import "";
project-spa>node_modules -List of all indiv loaded dependencies
	angular snippets a-, ng-, fx-
git remote add origin <gitub>		(+) -> "Message"-> ... push to


.NetCore StartUp.cs (Program reads to start up the app)
//ConfigureServices Called at runtime. Shell to add + hold services for DI.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            services.AddDbContext<AppContext>(o =>
                o.UseSqlite(Configuration.GetConnectionString("defaultConnection"))); //appSettings.Dev.json
              
            services.AddCors();
        }
// Use this method to configure the HTTP request pipeline.
        // This is middleware to interact w/ Req on its journey to deliver a Resp
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
CORS - Browser security feature that protects you from accessing data from an unknown origin. 
API is a foreign site (localhost:5000) being Requested by angular (localhost:4200) 
A coors policy is needed else an ERROR - "No Access-Control-Allow-Origin" header is coming from request
		app.UseCors(req => req.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());
            	app.UseRouting();
EntityFramework commands
dotnet ef -h	dotnet ef migrations -h		dotnet ef migrations add <name>
dotnet new -h	dotnet new webapi -n DatingApp.API
dotnet --info display all your sdk's + info
IActionResult= Http Resp   
async Task= Doesn't block other Reqs in thread while waiting for returned resuts 
  	Microsoft.EntityFrameworkCore  Microsoft.EntityFrameworkCore.Design  Microsoft.EntityFrameworkCore.Sqlite
-----------------------------------------------------------
Day 2:
dotnet ef migrations add <name>		Add updates to existing migration file <update name>
dotnet ef database update 		Update these changes to the DB
Repository Pattern(I)-  If we change ORM, this will not change
	Layer between EF and Controllers.  Repo exposes methods for (C) to use
	(C) (Repo/ServiceImpl)(Repo/ServiceI) (EF Context)(Linq)->(DB)
Methods can accept params or export values 
Output params were used to initialize local variables inside another method
	public void SomeMeth(int x, out int[] arr1, out string theOutput){}
Task<User> = Just a User obj that is wrapped in a Task for Threading (use async await)
_context = Middleware (Program<->DB) needs to track changes of entities
	Else it connot be persisted(saved) state needs to be added to be saved
	await _context.User.AddAsynch(userObject);	--Track changes to the domain.model
	await _context.SaveChangesAsynch();	//Middleware to persist any tracked changes
FirstOrDefaultAsynch(x => x.Id == id) returns null if not found
	without the Asych part, an Exception would be thrown
System.Security.Crytography - Objects you can create that can scramble inputs like passwords
	using their method like computeHash.  These objects have this secret hash output 
	but, also provide a key.  With this key you can replicate the hash given another crpyto object
	The unique key is called a "Salt"  use this key to reverse-engineer.  Just create another 
	cryto object and pass it the previous key.  Now It's output will be the same as your original cryto object
-------------------------------------
Day 3:
Registering Services in the StartUp class --Make Services injectable throughout the App
 	services.AddSingleton<IService, TProvider> = Single instance created on 1st request.  
	This instance is shared across across all new requests.  Problem when you have concurrent requests
	AddTransient<IS, TP> = New instance created of repo for each http request
	  Good for stateless services
	AddScoped<> = Created only once per Req w/i the same scope.  
	  Uses this single instance when other calls made as part of this Request.  
	  The user's initial Request is grouped as a scope so, same instance is used during
	  this user session. Good for an Auth Repo request because they are tied to a single session
	AddScoped<IAuthRepo, ImplAuthRepo> = The (I) is injected into the (C) so, 
	  the Controller code DOES NOT change.  Any changes happen in the impl class 
Repository Pattern = (I) amd (Impl).  The Repo interface is injected into the (C)  so, that
	The controllers logic does not need to change.  All changes about talking to the DB
	happen in the Impl Repo.  Seperations of concerns so, (C) deals w/ Req/Resp
	Repo deals w/ talking to DB and the Repo(I) is injected to the Controller.  
	Register Repo as a service in the StartUp file so, it can be injected anywhere in the App.		
Creating API Controllers
	using Microsoft.AspNetCore.Mvc;  =Using MVC
	[Route("api/[controller]")]    
    	[ApiController]			Attribute based routing is enforced by using [ApiController]
    					If removed we can use standard routing + auto-validates Req
	public class ValuesController : ControllerBase = MVC (C) NO Views
				      : Controller = 	 MVC (C) Allows Views	
DTO's - Used to map Models into simpler objects	
	DTOs are kept in a separate folder DTOs...ObjNameDto.cs
	They have less info than the Object they mimic
	I.E.  User Object has username, pHash, pSalt but no actual password so, a dto was created
	  just to capture Username and Password.  The DTO object that has data still needs to 
	  transfer that data into the actual obj.  
	Generally received by the (C) as an object --Has the info we want from form/user
	Converted to actual object in the (C) b/c we need real obj to save to the DB
------------------
Day 4:
ServerSide Validation
[ApiController]  Attribute of the (C) class does a lot of work for us
  Infers [FromBody] in the (m) params.  Tells server this is obj vs. "Null"
    Don't need to if(!ModelState.IsValid()) return BadRequest( ModelState )
    Infers that a Post requires an object and sets the Model(obj) as an obj vs "Null"
  DataAnnotations done on the model that is interacting with the Client
  [MinLength(4, ErrorMessage = "Must be at least 4 characters")]
  [StringLength(50, MinimumLength = 4, ErrorMessage = "Must be between 4-50 characters")]
Token Authentication - How the client authenticates against the API.  With this auth
  a user cannot make up their own token and send to the server.  Even if they have the username 
  b/c the server has its own signature which verifies each token.  The server uses a secret key
  to ensure that the token is valid...The token cannot be manipulated..Won't pass server check
  JWT = Json Web Tokens (industry standard) https://jwt.io/
	Self contained (Credentials, Claims to the app + more)
	Doesn't go to DB to validate, calls the token itself
	JWT is  text file 
		1.Header("alg":encryted algo  "typ":"JWT")
		2.Payload( info stored inside the token ) careful-Thses can be easily decoded
		3.Secret(Used to Hash 1+2) stored on the server and never revealed to the client
		  secret is included with JWT by client that the server can validate
		  secret being passed needs to match ... else not a valid token
	Returning token to users so, they can authorize themselves next time
Identity Claims - (C) login)) We build the identity of the user by new Claim("type", "value")
  	These are Claims that we make about them to identify who they are
        var claims = new[]
            {
                new Claim(ClaimTypes.NameIdentifier, userFromRepo.Id.ToString() ),
                new Claim(ClaimTypes.Name, userFromRepo.UserName)
            };
Using Authentication Middleware - Once you have authorization set up in your (C)
	Microsoft.IdentityModel.Tokens
  	System.IdentityModel.Tokens.Jwt
  	Microsoft.AspNetCore.Authentication.JwtBearer
  The Startup.cs -ConfigureServices(CS services)
  Authentication as a "service" set-up Startup.cs (Define what type of auth using)
	 services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(o =>
                {...}
http pipeline needs to be set up 
Configure(IApplicationBuilder app
  app.UseAuthentication(); --Can this Req(user) be authorized...Both are required
  app.UseAuthorization();  --If so, what can he do
    This must happen before 
    UseEndpoint/UseMvc().  Because, we want to short circuit the http pipeline and protect
    The (C) and its methods from unauthorized users 
Use token to authorize users against the API and protect Servre resources. 
 	(C) [Authorize] = Each request requires authorization Token
	    [AllowAnonymous] = method attribute = No authorization token required 
Testing Authentication
	Postman -> Request url -> Header(K,V) Authorization : Bearer "token string from successful login"
1.Github Hiding the token key from being pushed to Github
	Normal = Source control -> stage (+) -> "message" -> commit (enter) ...secrets are pushed
	Hide a file(1) = .gitIgnore file ...add the file to omit from being pushed to Git
		.vscode bin obj *.db appsettings.json
	Remove from staging(2) = 	git rm appsettings.json --cached
		Removes from staging.  Keeps chnages as local.  Does not go with push request
2.Github Hiding the token key from being pushed to Github
  Use this for DEV mode only.  Must use ENV Variables in prodution
	(1)dotnet user-secrets init	Adds secrets GUID to <PropertyGroup>
	<PropertyGroup>
    		<TargetFramework>netcoreapp3.1</TargetFramework>
    		<UserSecretsId>d316194c-5298-416c-84f9-1611dc803cc2</UserSecretsId>
  	</PropertyGroup>	
					("Section:Key" "value")
	(2)dotnet user-secrets set "AppSettings:Token" "the token value later to byte[] in Login controller"
		This (k,v) from appsettings.json now exists as a secret in local computer
		dotnet user-secrets list	retreives token value from local
	(3)Remove "AppSettings": { "Token": "..."} from appsettings.json
Summary:
	Passwords in Db are stored as password hash + salts(key)... not visible text
	  Even if two passwords are the same they will have a different Hash b/c
	  a new security crypto object (unqiue key) is created making the key + hash
	  specific to that object each time a user registers (C-Register->authRepo->register->createPasswordhash)
	JWTokens can be passed from client to the server to authenticate the user.
	    Since JWT are signed with a secure key, no DB call to server to check if authenticated
	    Because, they are sending request with the Token we have already provided 
	    ensuring authentication for a given period of time
------------------
Day 5:	 
Creating the Nav & Login form   
Turn html form into an angular form gives you:
	change tracking, two-way binding, validation and error handling
		Template reference = variable to assign "ngForm" directive 
		    #..="ngForm"
		Turns on Angular for this <form> by assigning var + directive
	<form #loginForm="ngForm"  (ngSubmit)="login()">				
		Must import: FormsModule in app.module.ts
(click) vs (ngSubmit)="..."
	Click is on the element.  NgSubmit is written on the form tag
<input name="password" Attribute is used by Angular to assign and register the input
<input name="password" required	   placeholder="put passord here"  -required field + placeholder
<imput name="password" [(ngModel)]="model.password" -2-way binding to model:any={} in component

Angular validation, form-states / field-states used for tracking
	Add reference var to access outside of the tag		#password="ngModel"
	Remove this field level reference variable.  It is only used for testing
	Allows for 2-way binding so, you can see pas field states

<div>	Form Valid: 	{{ #loginForm.valid }}  	Are all required fields populated entire form
	Form Values 	{{ #loginForm.value | json}}	Values populate as you type
	Password Valid	{{ password.valid  }}		.valid = required field is populated
	Password Value	{{ password.value  }}		2-way binding value will be printed
</div>

<button [disabled]="!loginForm.valid"  	   Disable this button if the validation state of
					   the form is invalid.  Else, enable the button
					   so, the button can be clicked and data passed
------------------
Day 6:  
Creating services
	1.  Make a folder "_services" to hold all of your services
	2.  ng g service auth 	-> component: auth.service.ts 	export class: AuthService 
	Service = Centralizing the API req/resp to a single location vs. duplicating
		  code in every class
		1.  Use services to create methods that communicate with API as a stream
		    send http methods Req-> get back a stream as the Resp.  In AuthService, we are 
		    expecting a token (k,v) "Token" : "Token string" has:
			a.  Header- What kind of security, what is it (k)
			b.  Payload - Body that has some info about response
			    How long is this token valid for start/end + some passed data
			c.  Signature - Encryted string that comes from server and only that
					string can be sent back.  No other combo will work
					This Verifies each token and allows authenticated communication
					as long as the exact security string comes back with the user
					log-in credentials
		2.  Components are auto-injectable but Services are not
		    @Injectable decorator = You can inject this instance to another class as DI
		    providedIn: "root" = Which module is providing this service?  The root module is
		    Add Service as a provider - manually
		    app.module.ts	providers:[AuthService] is autoregistered at the root level module 

Observables	import { Observable } from 'rxjs';	working with REST API's
							
	In order to do something with a Resp (from server).  You need to use rxjs operators
	You pass these operators(filter/map/reduce) through a pipe method so, you can chain 
	rxjs operators to the request.	import { map } from "rxjs/operators";
	The .pipe returns Observable<void> ...remember, Observables are lazy so, they don't
	  return anything.  You must subscribe to them to elicit the data

	return this.http.post("url", obj) 
		= use return + http.(req type) method to send Req to API  
		= interprets the body as JSON and returns it as an Observable in JSON
		.pipe() 		= transform the response to your request as Observable
		.map( (Resp)=>{})	= transform incoming values on-at-a-time
		  const user:any = response;	= cal response user since we are receiving
						  JSON token which represents the auth of
						  our user "token" : "security token string"	
		  if (user) { localStorage.setItem("token" : user.token)}
						= store the response as (k,v) in the browser
						  since Resp comes back as JSON, it is serialized
						  to a string. Asigning "ObjKeyName", calling Obj.Key = value 
Localstorage = store (k,v) in a web browser.  data is persisted so, close browser | refresh page 
data still there (persisted).  (-) You can only store strings, store as json  

rxjs Operators						import { map } from "rxjs/operators";
	const filterOutWithEvens = filter(x => x % 2)
	const doubleByValue = x => map(value => value * x);
	const sumValue = reduce((acc, next) => acc + next, 0);
	const source$ = Observable.range(0, 10)

	source$.pipe(
  	  filterOutWithEvens, 
  	  doubleByValue(2), 
  	  sumValue)
  	  .subscribe(console.log); // 50
------------------
Day 7: 
Getting data from the browser
	Console: Message you send to the log
	Network: Where you see your Req/resp info .. Click on indiv. req to see req/resp info
	Application:  Storage- Local/Session/Cookies, Cache-
Conditional method to use in *ngIf="loggedin()"
	loggedin() : boolean{ const token = localStorage.getItem("key") } 
	return !!token;		---T/F item present or not
		Same as below
	if (token) return true;  Else return false;
					template reference
Conditionally render the Nav Bar using <form #loginForm="ngForm" *ngIf="!loggedIn()" 
	put conditional on element to show/hide
	  method returns boolean ...method constantly running/listening.  So, when/if  
	  conditions change, method value changes(T/F) -> ngIf shows/hides this element
Alternate pattern for toggling
	1.  make a variable in the component 	regMode: boolean = false;
	2.  set this var as an *ngIf="regMode"  vs.  *ngIf="!regMode" on 2 elements to swap
	3.  set an event (click)="toggle()"
	4.  In component set toggle() {this.regMode = !this.regMode}
	5.  This toggles both listening ngIf's so, only 1 is present
		a.  The one you want on 1st set to !regMode = (!false)
		b.  When toggled this will go away and the other will appear
------------------
Day 8:
Global exception handling  
	properties -> launchSetting.json  "Development" -or- switch to "Production"
	  you want to use global exception handling to limit try/catch blocks in ea class		
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())			Exception Handler adds middleware to the
            {						 pipeline.  That catches the exceptions 
                app.UseDeveloperExceptionPage();	 logs it-> re-executes the request in an 
            }						 alternate pipeline...so, no unhandled, this
            else					 is handling ...I.E equivenant of global try/catch
            {
                app.UseExceptionHandler(builder =>	This needs to be configured and returns IApplicationBuilder
            }						Set all exceptions as 500, output our custom Extensions class method "AddApplicationError"
							passes our error to the response.  Return s status 500 w/ message in the headers
------------------
Day 8:
Wrapping 3rd party libraries as an Angular service.  Get a 3rd party app for cool alerts and turn it into an 
Angular service.  Do install, then make a service (so components can inject to use).  make teh methods of 
this service (success, fail, warn).  based on the imported libraries, when used, altertify makes cool pop ups
for succes + message you pass.  You use these DI this service into a component, then calling their methods
and passing in the custom message
	Alertifyjs.com - Notifications (sucess/failures) from browser
		npm install alertifyjs	DatingApp > spa
		spa > src > styles 	@import "../node_modules/alertifyjs/build/css/alertify.min.css"
					@import "../node_modules/alertifyjs/build/css/themes/bootstrap.min.css";
		spa> src > app > services			ng g service alterify
			import all alertify methods/libraries	import * as alertify from 'alertifyjs'
			spa> src > new file     typings.d.ts	declare module 'alertifyjs'
			spa> tsconfig.json
	alertify.service.ts
		Add confirm/success/error methods in this .ts then use them in other components
		Import AlertifyService into constructor
			login(){
				this.service.login(this.model)
				.subscribe(
					next=>{this.alertify.success("")},
					err =>{this.alertify.error(err)}
				);
				}
Angular JWT - Token helpers - 3rd party library to help manage tokens	https://github.com/auth0/angular2-jwt
	npm install @auth0/angular-jwt	
	import {JwtHelperService} from "@auth0/angular-jwt"
	--Building this in service, this way you can check JWT status by injection vs in each component
	jwtHelper = new JwtHelperService();
	loggedin(){	//comming in as a service 

    		const token = localStorage.getItem("token");
    		return !this.jwtHelper.isTokenExpired(token);
	loggedIn(): boolean {	--consumed by a component

    		return this.authService.loggedin();

NGX Bootstrap - 3rd party library to integrate bootstrap with Angular.  Best practice is not to use jQuery but,
pure Angular and integrate Angular based libraries.		https://valor-software.com/ngx-bootstrap/#/dropdowns
-basically after installed, just add some NGX specific key words to elements to use features.  
	install at the spa level	ng add ngx-bootstrap
	add NGX module to module root	import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
					import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
	register module in imports	import: [BrowserAnimationsModule,
    						 BsDropdownModule.forRoot()]	
	<div dropdown>  		Keyword needed on surounding elem to indicate this is a dropdown
	  <a dropdowntoggle>Welcome	Kw when using <a>, what you click on to display dropdown options (on-off)
	  <div *dropdownMenu>		The inner items are <a> link as drop down options.  
		<a>item1</>	  	This Kw just groups these items that will be shown as drop-down options
		<a>item2</>	  	* this is a structural directive that changes the DOM directly	

-minor fixes in CSS of the nav bar we added a pointer when using the dropdown, dropdowntoggle, the items of teh drop down
	.dropdown-toggle, .dropdown-item{  cursor: pointer;  }
-Hid the NavBar menu items to only show if a user is logged in.  Targeted <ul> holding <li> each menu item
	<ul class="navbar-nav mr-auto" *ngIf="loggedIn()">
            <li class="nav-item active">
                <a class="nav-link" href="#">Matches </a>
-Drop down items were too close to the "dropdowntoggle" which shows >Welcome Username<
The "dropdownMenu" sourounding each item needed some margin-top so, they werent mashed together...to effect all grouped items
	<div class="dropdown-menu mt-3" *dropdownMenu>


Bootswatch - Change theme of design free (through Bootstrap)		https://bootswatch.com/help/
	npm install bootswatch		install Bootswatch at the spa level 
	spa>node_modules		These are the project dependencies-> will show "bootswatch"
	bootswatch>dist			This holds all the avaialble themes, so you know path to point to
	spa>app>src>styles.css		@import "../node_modules/bootswatch/dist/flatly/bootstrap.min.css";

from bootswatch, dropdown to theme used "flatly". <> means check out the code.  Only one change was made 
	<nav class="navbar navbar-expand-lg navbar-dark bg-primary"> changed to bg-primary to match theme better

------------------
Day 9:
Set-up up Angular routing.  
We need somewhere to route when people/click on links in the navBar and go to the appropriate
page (Angular component).  Within the app-component level create components to ...   
	ng g c member-list	Display a list of other users with details ... as cards
	ng g c list		Keeps track of users that, this user likes -or- have liked this user 
	ng g c messages
		Components should be auto-registered as declarations:[components that roll up to app root] in app.module
	echo > routes.ts 	make a file that contains routes for our application
	src>app		touch routes.ts		new file in bash (non-windows)
			import { Routes } from '@angular/router';

How to set route paths?
After you have created routes.ts  Define Routes=[] as an array of objects{}. make paths -> components 
Order is important.  ** if no path round redirect to the home screen  
				export const appRoutes: Routes = [
    					{which path: "", will match to our angular component: compName},
					{ path: "list", component: ListComponent },
    					{ path: "**", redirectTo: "home", pathMatch: "full" }
				]
Register your routing the the app
Enable routing capabilities for the Angular app...
Register the Routing module at the app root level "app.module"
app.module allows the entire app to use any registered modules + auto-registers components to roll up to this app-root

import {RouterModule} from "@angular/router";	import { appRoutes } from "./routes";

	import: [					.forRoot() takes 1-2 args and configures
	RouterModule.forRoot(appRoutes)]  		this module with any routes we provide.	
	
 
In this case we have configured using appRoutes from our export of routes.ts
--------------
Day 10:
How to use [routerLink] in html templates for <a> navigation

Setting up links(we just made) in the Nav Component
This tells Nav bar where to direct people to when they click on <a> by changing the URL
--Adding [routerLink]  to the nav.html ...a-routerlink(short-cut)

	href="#"  vs.  [routerLink]="['/routePath']" routerLinkActive="router-link-active"

<li class="nav-item" routerLinkActive="active">				light-up on click/hover
	<a class="nav-link" [routerLink]="['/lists']">Lists</a>		changes url tree to host/lists
</li>									links rourter to this path...click <a>

--Converting the app.component structure -> RouterOutlet structure
<app-nav></app-nav>
<router-outlet></router-outlet> 	vs	<app-home></app-home>   selector
	when the route is host/home...The home component still exists and has the register selector as a child
	but, by putting the outlet here.  The <a>routes are inside of the nav.comp.html  Therefore only NAV comp 
	is shown but, ** in routing defaults to "home" host:4200/home.  Home view is auto displayed with 
	register & learMore buttons.  Click<a> from nav bar is how you access to the other components. 
	Which are all (on/off) based on the login -or- not loggedin 

--Redirecting user on login-> "members" to display a list of members  vs.  logout-> home
	Use angular Routing as an injectable service to put into .ts components when methods are called 	
					
							import {Router} from "@angular/router";
							constructor(private router: Router){}

	app-nav.html has on-click <a>routing to url paths & login()/logout() methods we want to effect
	Use these methods to effect routing when methods are being called
	1. Effect routing from an observable method
	   We have injected Routing + the login() is subscribed to the authService api call
		next 	= Req is successful, resp has data back from api
		error 	= data stream has a passed error that we are grabbing/passing and returning to browser via alertify
		complete= ()=> {after all next's are called, do this, returns void}

           Observable<void>.subscribe( next?: (val:void)=>void, error?: (error:any)=> error, complete?: ()=> void )
 
			login(): void {
			this.authService.login(this.model)
      				.subscribe(
        				next => {this.alertify.success("Logged in successfully");
					error => { this.alertify.error(error); },
					() => { this.router.navigate(['/members']); }
				);

	2. Effect routing from regular method
			logout(): void {

    					localStorage.removeItem("token");
    					this.alertify.message("logged out");
    					this.router.navigate(['/home']);
  					}
		*Notice that the router.navigate(['url-path']) is void like all statements in this method
		The routing is being updated and nothing is being returned

in methods 	= router.navigate([''])
in html 	= [routerLink]="['/lists']"

--Using Routeguards to protect routes from unauthorized users.  implements CanActivate ... can this route 
	be activated (t/f)
	
	src>app		mdir _guards			Make a dir to hold auth guards for routes
	cd _guards	ng g guard auth	--skipTests	Make guard with no tests(spects.ts)
							which interfaces to use...space to select
							select "CanActivate" return
	
auth.guard.ts is kinda like a separate component.  I stripped off most return options since this is just a bool to 
see if, a user is logged in or not.  If not logginIn, they can only access the home page. Now you can DI
the guard to use this protection.

	export class AuthGuard implements CanActivate {

  	constructor(private authService: AuthService,
    		private alertify: AlertifyService, private router: Router) { }

	canActivate(): boolean {

    		if (this.authService.loggedin())    //Req of canActivate true = user can proceed
      			return true;

    		else {
      			this.alertify.error("Requires valid login to access this area");
    		}
  	}

Using a guard in the appRoute configuration class routes.ts to effect a single route	
routes.ts	

	import { AuthGuard } from "./_guards/auth.guard";				can only acces this route
											if the guard is true.  Pass the guard
	 { path: "members", component: MemberListComponent, canActivate: [AuthGuard] }		

*canActivate:  []
Is a type that can hold an array of guards  
An array of dependency-injection tokens used to look up CanActivate() handlers, in order 
to determine if the current user is allowed to activate the component. By default, any user can activate.


Using guards to protect multiple routes
	create a single route in routes.ts (serarate route object{} in array of Routes=[])
	to guard many routes by passing route/path in as children ... within routes.ts

	export const appRoutes: Routes = [

		{ path: "", 				//localhost:4200 +blank path to add onto this 
		  runGuardsAndResolvers: "always",	//always run guards for these children
        	  canActivate: [AuthGuard], 		//This single guard (one of many)
        	  children: [
            		{ path: "members", component: MemberListComponent },
            		{ path: "messages", component: MessagesComponent },
            		{ path: "lists", component: ListComponent }
        ]
		},

-------------
Day 6: 
Angular @Input @Output Property binding
This is how you pass data from one componet to another so that its avaialble
for the other components template

1.  Transfer data from p->c receiving @input within the c component 
	(p)
	P_input:string;
	<input type="text"   [(ngModel)]="P_input">
					    v
 	        <app-child [parentTxBx] ="P_input"> </app-child>
	(C)
	@Input("parentTxBx")parentTxBxVal: string;
	<p>Value of Parent TextBox:  {{parentTxBxVal}}

2.  Transfer data from p->c receiving @input within the c component 
	(p)
			pClick: Subject<void> =new Subject<void>();
	OnPclick(){this.pClick.next();
			   v
	<button (click)="OnPclick()">Parent Click</button>	
			   v
    <app-child [pBclick]="pClick"  >
	(c)
		   v
  	@Input("pBclick") parentClick:Subject<void>;
	clickCount:number=0;
				//On-click Subject observable is fed a new Subject
				//Increment is called on clickCount
	ngOnInit(): void {
    		this.parentClick.subscribe(()=>
      		this.incrementValue() );
  	}
  	incrementValue(): void{
    		this.clickCount= this.clickCount+1;
  	}
	<div> Parent click count : {{parentClick}} </div>

3.  Transfer data from c->p receiving @Output within the p component 















